<!DOCTYPE html>
<html xml:lang="ca-ES" lang="ca-ES" xmlns="http://www.w3.org/1999/xhtml">
<head>

	<title>Autenticació amb JWT a una aplicació Canigó 3.1</title>
		<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" />
	<link href="/css/master.min.css" rel="stylesheet" type="text/css" />
	<link href="/css/canigo.css" rel="stylesheet" type="text/css" />
	<script src="/js/jquery.min.js" type="text/javascript"></script>

	<script>
		document.write("<meta name=\"titol\" content=\"Autenticació amb JWT a una aplicació Canigó 3.1\" />");
		document.write("<meta name=\"description\" content=\"Autenticació amb JWT (JSON Web Tokens) a una aplicació Canigó 3.1.x (REST\/HTML5\x2bJS)\" />");
	</script>

	

</head>
<body class="single">
	<div class="contenidor unfixed">

				

		<header class="fons_header navbar navbar-default z-index-menu">
			<div class="container" role="menu">
				<div class="row clearfix menuNav">
					<div class="col-md-3 col-xs-3 column visible-xs coloca ">
						<button type="button" onclick="amunt();" title="Menu"
							class="navbar-toggle pull-left" data-toggle="collapse"
							data-target=".navbar-collapse">
							<span class="sr-only">Toggle navigation</span> <span
								class="icon-bar"></span> <span class="icon-bar"></span> <span
								class="icon-bar"></span>
						</button>
					</div>

					<div class="col-md-3 col-xs-6 col-offset-2 column visible-xs titol-mobil">
						
						<span class="white titol-mobil-destacat">canigo.ctti</span><span class="white">.gencat.cat</span>
					</div>

					<div class="col-md-3 col-xs-3 column visible-xs coloca1">
						<button onclick="amunt();" type="button" title="Cerca"
							class="ico_cerca " data-toggle="collapse" data-target=".dos">
						</button>
					</div>

				</div>

				<div class="collapse dos">
					<div class="shadowBox">
						<form class="navbar-form navbar-left primer" action="/cercador/" method="get"
 						onsubmit="location.href=this.action+'?q='+this.cerca_cap.value; return false;">
							<div class="form-group">
								<input type="search" class="form-control" name="q" id="cerca_cap"
									title="Cerca"
									placeholder="Cerca" />
								<button type="button" title="Neteja" class="btn btn-default"></button>
								<input type="submit" class="ocult" name="Cerca" value="Cerca" />
							</div>
						</form>
					</div>
				</div>	

				<nav class="collapse navbar-collapse navbar-ex1-collapse ">
				
					<div class="row">
						<div class="col-md-6 col-sm-4 column">
							<a class="img-responsive logo" title="Generalitat de Catalunya"
								href="https://ctti.gencat.cat/">gencat.cat</a>
							<button class="menu_tancar visible-xs collapsed"
								data-target=".navbar-collapse" data-toggle="collapse"
								title="Tancar"></button>
						</div>

						<div class="col-md-6 col-sm-8 column hidden-xs hidden-mg">
							<form class="navbar-form cercador_vermell hidden-xs pull-right" action="/cercador/"  method="get" onsubmit="location.href=this.action+'?q='+this.cerca2.value; return false;">
								<div class="form-group">
									<label class="hidden" for="cerca2">Cerca</label>
									<input id="cerca2" class="form-control" type="search" 
									placeholder="Cerca" name="q" title="Cerca">
									<input class="btn btn-default" type="submit" title="Cerca" value="">
								</div>
							</form>

							

						</div>

					</div>
					<div class="col-xs-12 hidden-xs" id="nomPortal">
                    	<span class="titol-cap-nou">Centre de Telecomunicacions i Tecnologies de la Informació</span>
                    </div>					
					<ul class="nav navbar-nav">

			        	

						<li>
							<a class="dropdown-toggle" href='/' data-toggle='_dropdown'>Inici</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/arqctti' data-toggle='_dropdown'>Arquitectura CTTI</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/blog' data-toggle='_dropdown'>Blog</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/cloud' data-toggle='_dropdown'>Cloud</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/canigo' data-toggle='_dropdown'>Canigó</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/sic' data-toggle='_dropdown'>SIC</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/sgde' data-toggle='_dropdown'>SGDE</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/gicar' data-toggle='_dropdown'>GICAR</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/cs' data-toggle='_dropdown'>Centres de Suport</a>
						</li>

						

						<li>
							<a class="dropdown-toggle" href='/dadesref' data-toggle='_dropdown'>Gestió Tècnica de Dades</a>
						</li>

						

					</ul>

				</nav>
			</div>
		</header>



	</div>

	<section class="border-start">

						
			

			<article class="bgGrey">
				<div class="container">
					<div class="row">
						<div class="capcelera_basica col-sm-12">
							<div class="capcelera_basica_cont">
								<ol class="breadcrumb filariana hidden-xs">
									<li>
										<a href="/">Inici</a>
									</li>
									<li class="breadcrumbs2">
									
										<a href="/howtos">
											











	How to


















										</a>
										




























































































									
									</li>

								</ol>

								<h1 class="capcelera_flotant pull-left" data-txt=".title">
									

										
											




	Autenticació amb JWT a una aplicació Canigó 3.1


										

									
								</h1>

								

								
								

								

								

							</div>
						</div>

					</div>
				</div>
			</article>

			


		   <div class="padding-xs container">
	    	
	    	   <i><b>Darrera actualització:</b></i> 30-11-2016
	        
           </div>
           
			<article class="padding-xs padding-sm padding-md contingut">				
				<div class="container">
 		
					
				

	


					

						

<h3 id="a-qui-va-dirigit">A qui va dirigit</h3>

<p>Aquest how-to va dirigit a tots aquells desenvolupadors/arquitectes que vulguin autenticar amb JWT a una aplicació Canigó 3.1 (REST+HTML5/JS).</p>

<h3 id="versió-de-canigó">Versió de Canigó</h3>

<p>Els pasos descrits en aquest document apliquen a la versió 3.1.x del Framework Canigó.</p>

<h3 id="introducció">Introducció</h3>

<p>En aquest HowTo s’explica com autenticar amb  JWT a una aplicació Canigó 3.1 REST. Per a fer-ho desplegarem l’aplicació demo que genera el plugin de Canigó amb seguretat per BBDD (amb una base de dades HSQLDB en memòria).</p>

<h2 id="configuració">Configuració</h2>

<h3 id="afegir-llibreries">Afegir Llibreries</h3>

<p>S&rsquo;ha d&rsquo;afegir al pom.xml la dependència amb Java JWT:</p>

<pre><code>&lt;!-- JJWT --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
    &lt;version&gt;0.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3 id="configuració-petició-resposta">Configuració Petició/Resposta</h3>

<p>Per configurar JWT primer de tot creem les classes de petició, resposta, i el handler d&rsquo;aquesta resposta:</p>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/dto</em> generem les següents classes:</p>

<p><strong>AuthenticationRequestDto.java</strong>, per a la petició:</p>

<pre><code>package cat.gencat.canigorest311.security.authentication.dto;

import java.io.Serializable;

public class AuthenticationRequestDto implements Serializable {

    private static final long serialVersionUID = 3237170924587387745L;

    private String username;
    private String password;

    public AuthenticationRequestDto() {
        super();
    }

    public AuthenticationRequestDto(final String username, final String password) {
        this.setUsername(username);
        this.setPassword(password);
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(final String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(final String password) {
        this.password = password;
    }
}
</code></pre>

<p><strong>AuthenticationResponseDto.java</strong>, per a la respsota</p>

<pre><code>package cat.gencat.canigorest311.security.authentication.dto;

import java.io.Serializable;

public class AuthenticationResponseDto implements Serializable {

    private static final long serialVersionUID = -576643360234236041L;

    private final int code;

    public AuthenticationResponseDto(final int code) {
        this.code = code;
    }

    public int getCode() {
        return code;
    }
}
</code></pre>

<p><strong>JwtAuthenticationResponseDto.java</strong>, per al token</p>

<pre><code>package cat.gencat.canigorest311.security.authentication.dto;

import java.io.Serializable;

public class JwtAuthenticationResponseDto implements Serializable {

    private static final long serialVersionUID = -5766433606831683041L;
    private final String token;

    public JwtAuthenticationResponseDto(final String token) {
        this.token = token;
    }

    public String getToken() {
        return token;
    }
}
</code></pre>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/response</em> generem les classes utilitzades a la resposta:</p>

<p><strong>ResponseRest.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.response;

import java.io.Serializable;

public class ResponseRest implements Serializable {
    /**
     *
     */
    private static final long serialVersionUID = -89237367748293773L;
    private int code;
    private String message;

    public ResponseRest() {
        super();

    }

    public ResponseRest(final int code, final String message) {
        super();
        this.code = code;
        this.message = message;
    }

    public int getCode() {
        return code;
    }

    public void setCode(final int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(final String message) {
        this.message = message;
    }
}
</code></pre>

<p><strong>ResponseRestOk.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.response;

public class ResponseRestOK extends ResponseRest {

    private static final long serialVersionUID = -234121341241231L;

    public ResponseRestOK() {
        super();
    }

    public ResponseRestOK(final int code, final String message) {
        super(code, message);

    }

}
</code></pre>

<p><strong>ResponseRestError.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.response;

public class ResponseRestError extends ResponseRest {

    private static final long serialVersionUID = -12141241223455L;

    public ResponseRestError() {
        super();
    }

    public ResponseRestError(final int code, final String message) {
        super(code, message);

    }

}
</code></pre>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/handler</em> generem les classes utilitzades per a construïr la resposta:</p>

<p><strong>RestAuthenticationFailureHandler.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.handler;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.databind.ObjectMapper;

import cat.gencat.canigorest311.security.authentication.response.ResponseRestError;

@Component(&quot;restAuthenticationFailureHandler&quot;)
public class RestAuthenticationFailureHandler implements AuthenticationFailureHandler {

    @Override
    public void onAuthenticationFailure(final HttpServletRequest request, final HttpServletResponse response, final AuthenticationException exception)
            throws IOException, ServletException {
        builJsonResponse(response);

    }

    private void builJsonResponse(final HttpServletResponse response) throws IOException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON.toString());

        final ObjectMapper mapper = new ObjectMapper();
        final ResponseRestError error = new ResponseRestError(HttpServletResponse.SC_UNAUTHORIZED, &quot;401. Unauthorized&quot;);
        final String json = mapper.writeValueAsString(error);
        final PrintWriter writer = response.getWriter();
        writer.write(json);
        writer.flush();
        writer.close();
    }
}
</code></pre>

<p><strong>RestAuthenticationSuccessHandler.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.handler;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.databind.ObjectMapper;

import cat.gencat.canigorest311.security.authentication.response.ResponseRestOK;

@Component(&quot;restAuthenticationSuccessHandler&quot;)
public class RestAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(final HttpServletRequest request, final HttpServletResponse response, final Authentication authentication)
            throws IOException, ServletException {
        // We do not need to do anything extra on REST login success, because there is no page to redirect to
        builJsonResponse(response);
    }

    private void builJsonResponse(final HttpServletResponse response) throws IOException {
        response.setStatus(HttpServletResponse.SC_OK);
        response.setContentType(MediaType.APPLICATION_JSON.toString());

        final ObjectMapper mapper = new ObjectMapper();
        final ResponseRestOK error = new ResponseRestOK(HttpServletResponse.SC_OK, &quot;200. Login Sucess&quot;);
        final String json = mapper.writeValueAsString(error);
        final PrintWriter writer = response.getWriter();
        writer.write(json);
        writer.flush();
        writer.close();
    }

}
</code></pre>

<h3 id="configuració-jwt">Configuració JWT</h3>

<h4 id="handler-del-token">Handler del token</h4>

<p>Classe que s&rsquo;utilitza per a obtenir la informació del token (username, authorities):</p>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/jwt</em></p>

<p><strong>JwtTokenHandler.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.jwt;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import javax.annotation.PostConstruct;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.util.Assert;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

public class JwtTokenHandler {

    private static final Log logger = LogFactory.getLog(JwtAuthenticationFilter.class);

    public static final String SECRET_PASSWORD = &quot;***&quot;;
    public static final String CLAIM_KEY_USERNAME = &quot;sub&quot;;
    public static final String CLAIM_KEY_AUTHORITIES = &quot;authorities&quot;;

    private String secret;

    private Long expiration;

    public UserDetails getUserFromToken(final String token) {
        UserDetails user;
        try {
            final Claims claims = getClaimsFromToken(token);
            final String userName = claims.get(CLAIM_KEY_USERNAME, String.class);
            final String authorityes = claims.get(CLAIM_KEY_AUTHORITIES, String.class);

            user = buildUserDetails(userName, authorityes);
        } catch (final Exception e) {
            logger.error(&quot;Error getting user from token. Token is invalid?&quot;, e);
            user = null;
        }
        return user;
    }

    public String getUsernameFromToken(final String token) {
        String username;
        try {
            final Claims claims = getClaimsFromToken(token);
            username = claims.getSubject();
        } catch (final Exception e) {
            logger.error(&quot;Error getting userName from token. Token is invalid?&quot;, e);
            username = null;
        }
        return username;
    }

    public Date getExpirationDateFromToken(final String token) {
        Date expiration;
        try {
            final Claims claims = getClaimsFromToken(token);
            expiration = claims.getExpiration();
        } catch (final Exception e) {
            logger.error(&quot;Error getting expiration date from token. Token is invalid?&quot;, e);
            expiration = null;
        }
        return expiration;
    }

    public String generateToken(final UserDetails userDetails) {
        final Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());
        claims.put(CLAIM_KEY_AUTHORITIES, StringUtils.join(userDetails.getAuthorities(), ','));
        return generateToken(claims);
    }

    public String generateToken(final Map&lt;String, Object&gt; claims) {
        return Jwts.builder().setClaims(claims).setExpiration(generateExpirationDate()).signWith(SignatureAlgorithm.HS512, secret).compact();
    }

    public Boolean canTokenBeRefreshed(final String token) {
        return !isTokenExpired(token) || ignoreTokenExpiration();
    }

    public String refreshToken(final String token) {
        String refreshedToken;
        try {
            final Claims claims = getClaimsFromToken(token);
            refreshedToken = generateToken(claims);
        } catch (final Exception e) {
            logger.error(&quot;Error refreshing token. Token is invalid?&quot;, e);
            refreshedToken = null;
        }
        return refreshedToken;
    }

    public Boolean validateToken(final String token) {
        return !isTokenExpired(token);
    }

    protected Boolean ignoreTokenExpiration() {
        return false;
    }

    private Claims getClaimsFromToken(final String token) {
        Claims claims;
        try {
            claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
        } catch (final Exception e) {
            logger.error(&quot;Error getting claimsfrom token. Token is invalid?&quot;, e);
            claims = null;
        }
        return claims;
    }

    private Date generateExpirationDate() {
        return new Date(System.currentTimeMillis() + expiration * 1000);
    }

    private Boolean isTokenExpired(final String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }

    private UserDetails buildUserDetails(final String userName, final String authorityes) {
        return new User(userName, SECRET_PASSWORD,
                StringUtils.isEmpty(authorityes) ? AuthorityUtils.NO_AUTHORITIES : AuthorityUtils.commaSeparatedStringToAuthorityList(authorityes));
    }

    @PostConstruct
    private void assertAfterPropertySet() {
        Assert.hasLength(secret, &quot;Secret (jwt.secret property) for JWT must not be null or empty!&quot;);
        Assert.notNull(expiration, &quot;expiration (jwt.expiration property) for JWT must not be null!&quot;);
        Assert.state(expiration &gt; 0, &quot;expiration (jwt.expiration property) for JWT must not be less than 0!&quot;);

    }

    public String getSecret() {
        return secret;
    }

    public void setSecret(final String secret) {
        this.secret = secret;
    }

    public Long getExpiration() {
        return expiration;
    }

    public void setExpiration(final Long expiration) {
        this.expiration = expiration;
    }

}
</code></pre>

<h4 id="entrypoint">Entrypoint</h4>

<p>Hem de generar la classe que indicarem a la configuració com a punt d&rsquo;entrada de l&rsquo;autenticació:</p>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/entrypoint</em> generem la classe <strong>RestAuthenticationEntrypoint.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.entrypoint;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import cat.gencat.canigorest311.security.authentication.response.ResponseRestError;

@Component(&quot;restAuthenticationEntryPoint&quot;)
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(final HttpServletRequest request, final HttpServletResponse response, final AuthenticationException authException) throws IOException {
        // This is invoked when user tries to access a secured REST resource without supplying any credentials
        // We should just send a 401 Unauthorized response because there is no 'login page' to redirect to
        final ResponseRestError error = new ResponseRestError(HttpServletResponse.SC_UNAUTHORIZED, &quot;401. Unauthorized&quot;);
        builJsonResponse(response, error);
    }

    private void builJsonResponse(final HttpServletResponse response, final ResponseRestError error) throws JsonProcessingException, IOException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON.toString());

        final ObjectMapper mapper = new ObjectMapper();
        final String json = mapper.writeValueAsString(error);
        final PrintWriter writer = response.getWriter();
        writer.write(json);
        writer.flush();
        writer.close();
    }
}
</code></pre>

<h4 id="controlador-de-l-autenticació">Controlador de l&rsquo;autenticació</h4>

<p>A l&rsquo;exemple hem generat un controlador REST (/auth) com a servei que hauria de cridar el login.</p>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/controller</em> generem la classe <strong>AuthController.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import cat.gencat.canigorest311.security.authentication.dto.AuthenticationRequestDto;
import cat.gencat.canigorest311.security.authentication.dto.JwtAuthenticationResponseDto;
import cat.gencat.canigorest311.security.authentication.jwt.JwtTokenHandler;
import cat.gencat.canigorest311.security.authentication.service.AuthenticationService;
import cat.gencat.canigorest311.security.authentication.service.impl.DefaultAuthenticationService;

@RestController
public class AuthController {

    @Autowired(required = false)
    @Qualifier(&quot;jwtAuthenticationService&quot;)
    private AuthenticationService jwtAuthenticationService;

    @Autowired(required = false)
    private JwtTokenHandler jwtTokenHandler;

    @RequestMapping(value = &quot;/auth&quot;, produces = MediaType.APPLICATION_JSON_VALUE, method = RequestMethod.POST)
    public JwtAuthenticationResponseDto getAuthToken(final HttpServletRequest request, final HttpServletResponse response,
            @RequestBody(required = false) final AuthenticationRequestDto jwtAuthenticationRequestDto) {

        if (jwtAuthenticationRequestDto != null) {
            request.setAttribute(DefaultAuthenticationService.SPRING_SECURITY_FORM_USERNAME_KEY, jwtAuthenticationRequestDto.getUsername());
            request.setAttribute(DefaultAuthenticationService.SPRING_SECURITY_FORM_PASSWORD_KEY, jwtAuthenticationRequestDto.getPassword());

        }
        final Authentication authentication = jwtAuthenticationService.authenticate(request, response);
        final String token = jwtTokenHandler.generateToken((User) authentication.getPrincipal());

        return new JwtAuthenticationResponseDto(token);

    }

}
</code></pre>

<h4 id="autenticació">Autenticació</h4>

<p>En aquest exemple només hem implementat el provider de l&rsquo;autenticació per defecte (DefaultAuthenticationService). Si l&rsquo;aplicació estiguès protegida per un altre provider, com per exemple GICAR, s&rsquo;hauria d&rsquo;implementar un GicarAuthenticationService per a realitzar l&rsquo;autenticació per GICAR.</p>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/service</em></p>

<p><strong>AuthenticationService.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.service;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.core.Authentication;

public interface AuthenticationService {
    Authentication authenticate(final HttpServletRequest request, final HttpServletResponse response);

    boolean isAuthRequest(HttpServletRequest request);
</code></pre>

<p>}</p>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/service/impl</em></p>

<p><strong>DefaultAuthenticationService.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.service.impl;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import cat.gencat.canigorest311.security.authentication.service.AuthenticationService;

@Component(&quot;defaultAuthenticationService&quot;)
public class DefaultAuthenticationService implements AuthenticationService {

    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = &quot;username&quot;;
    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = &quot;password&quot;;

    private String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;
    private String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;

    @Autowired
    @Lazy
    private AuthenticationManager authenticationManager;

    @Override
    public Authentication authenticate(final HttpServletRequest request, final HttpServletResponse response) {
        final String username = obtainUsername(request);
        final String password = obtainPassword(request);

        final UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);

        return authenticationManager.authenticate(authRequest);
    }

    protected String obtainUsername(final HttpServletRequest request) {
        final String username = request.getParameter(usernameParameter);
        return StringUtils.isEmpty(username) ? &quot;&quot; : username.trim();
    }

    protected String obtainPassword(final HttpServletRequest request) {
        final String password = request.getParameter(passwordParameter);
        return StringUtils.isEmpty(password) ? &quot;&quot; : password;
    }

    @Override
    public boolean isAuthRequest(final HttpServletRequest request) {
        return !StringUtils.isEmpty(obtainUsername(request)) &amp;&amp; !StringUtils.isEmpty(obtainPassword(request));
    }

}
</code></pre>

<p><strong>JwtAuthenticationService.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.service.impl;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;

import cat.gencat.canigorest311.security.authentication.jwt.JwtAuthenticationFilter;
import cat.gencat.canigorest311.security.authentication.jwt.JwtTokenHandler;
import cat.gencat.canigorest311.security.authentication.service.AuthenticationService;
import io.jsonwebtoken.lang.Assert;

public class JwtAuthenticationService implements AuthenticationService {

    private static final Log logger = LogFactory.getLog(JwtAuthenticationFilter.class);

    private String headerAuthName;

    private String tokenResponseHeaderName;

    @Autowired
    @Lazy
    private JwtTokenHandler jwtTokenHandler;

    @Autowired
    @Qualifier(&quot;defaultAuthenticationService&quot;)
    @Lazy
    private AuthenticationService defaultAuthenticationService;

    @Override
    public Authentication authenticate(final HttpServletRequest request, final HttpServletResponse response) {
        logger.info(&quot;try Authenticate whith credentials.&quot;);
        final Authentication authentication = defaultAuthenticationService.authenticate(request, response);
        ((AbstractAuthenticationToken) authentication).setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(authentication);
        response.setHeader(tokenResponseHeaderName, jwtTokenHandler.generateToken((User) authentication.getPrincipal()));
        logger.info(&quot;setting JWT token to response header. Authenticate user in Spring context.&quot;);
        return authentication;
    }

    @Override
    public boolean isAuthRequest(final HttpServletRequest request) {
        return (defaultAuthenticationService.isAuthRequest(request))
                || !StringUtils.isEmpty(request.getHeader(headerAuthName));
    }

    public String getHeaderAuthName() {
        return headerAuthName;
    }

    public void setHeaderAuthName(final String headerAuthName) {
        this.headerAuthName = headerAuthName;
    }

    public String getTokenResponseHeaderName() {
        return tokenResponseHeaderName;
    }

    public void setTokenResponseHeaderName(final String tokenResponseHeaderName) {
        this.tokenResponseHeaderName = tokenResponseHeaderName;
    }

    public JwtTokenHandler getJwtTokenHandler() {
        return jwtTokenHandler;
    }

    public void setJwtTokenHandler(final JwtTokenHandler jwtTokenHandler) {
        this.jwtTokenHandler = jwtTokenHandler;
    }

    public AuthenticationService getDefaultAuthenticationService() {
        return defaultAuthenticationService;
    }

    public void setDefaultAuthenticationService(final AuthenticationService defaultAuthenticationService) {
        this.defaultAuthenticationService = defaultAuthenticationService;
    }

    @PostConstruct
    public void checkProperties() {
        Assert.hasLength(headerAuthName, &quot;headerAuthName can't be null or empty!&quot;);
        Assert.hasLength(tokenResponseHeaderName, &quot;tokenResponseHeaderName can't be null or empty!&quot;);
    }

}
</code></pre>

<h4 id="filtre-autenticació">Filtre Autenticació</h4>

<p>S&rsquo;ha de crear un nou filtre per a comprovar a les url protegides si l&rsquo;usuari es troba autenticat, o en cas contrari intentar l&rsquo;autenticació.</p>

<p>Al path <em>src/main/java/cata/gencat/canigorest311/security/authentication/jwt</em> generem la classe <strong>JwtAuthenticationFilter.java</strong></p>

<pre><code>package cat.gencat.canigorest311.security.authentication.jwt;

import java.io.IOException;

import javax.annotation.PostConstruct;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;

import cat.gencat.canigorest311.security.authentication.service.AuthenticationService;
import io.jsonwebtoken.lang.Assert;

public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final Log logger = LogFactory.getLog(JwtAuthenticationFilter.class);

    private String headerAuthName;

    private String startToken;

    private String tokenResponseHeaderName;

    @Autowired
    private JwtTokenHandler jwtTokenHandler;

    @Autowired
    @Qualifier(&quot;jwtAuthenticationService&quot;)
    private AuthenticationService jwtAuthenticationService;

    @Override
    protected void doFilterInternal(final HttpServletRequest request, final HttpServletResponse response, final FilterChain chain)
            throws ServletException, IOException {

        if (requireDoFilter(request)) {

            final String header = request.getHeader(headerAuthName);

            if (header != null &amp;&amp; header.startsWith(startToken)) {

                final String authToken = header.substring(7);
                final User user = (User) jwtTokenHandler.getUserFromToken(authToken);

                final Authentication authenticationSecurity = SecurityContextHolder.getContext().getAuthentication();
                if (authenticationSecurity == null) {
                    if (user != null &amp;&amp; jwtTokenHandler.validateToken(authToken)) {
                        logger.info(&quot;token is valid, the user is autheticate correctly! setter response jwtToken&quot;);
                        final UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
                        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(authentication);
                        response.setHeader(tokenResponseHeaderName,
                                jwtTokenHandler.canTokenBeRefreshed(authToken) ? jwtTokenHandler.refreshToken(authToken) : authToken);
                    } else {
                        logger.info(&quot;token is invalid or missing!&quot;);
                    }
                } else {
                    logger.info(&quot;The user was previous authenticate!&quot;);
                }

            } else {
                logger.info(&quot;attemp to default authentication: call --&gt; wtAuthenticationService.authenticate&quot;);
                jwtAuthenticationService.authenticate(request, response);
            }
        } else {
            logger.info(&quot;The request:&quot; + request.getPathInfo() + &quot; has not info for authentication.&quot;);
        }

        chain.doFilter(request, response);

    }

    public String getHeaderAuthName() {
        return headerAuthName;
    }

    public void setHeaderAuthName(final String headerAuthName) {
        this.headerAuthName = headerAuthName;
    }

    public String getStartToken() {
        return startToken;
    }

    public void setStartToken(final String startToken) {
        this.startToken = startToken;
    }

    public String getTokenResponseHeaderName() {
        return tokenResponseHeaderName;
    }

    public void setTokenResponseHeaderName(final String tokenResponseHeaderName) {
        this.tokenResponseHeaderName = tokenResponseHeaderName;
    }

    public JwtTokenHandler getJwtTokenHandler() {
        return jwtTokenHandler;
    }

    public void setJwtTokenHandler(final JwtTokenHandler jwtTokenHandler) {
        this.jwtTokenHandler = jwtTokenHandler;
    }

    public AuthenticationService getJwtAuthenticationService() {
        return jwtAuthenticationService;
    }

    public void setJwtAuthenticationService(final AuthenticationService jwtAuthenticationService) {
        this.jwtAuthenticationService = jwtAuthenticationService;
    }

    @PostConstruct
    public void checkProperties() {
        Assert.hasLength(startToken, &quot;startToken can't be null!&quot;);
        Assert.hasLength(headerAuthName, &quot;headerAuthName can't be null or empty!&quot;);
        Assert.hasLength(tokenResponseHeaderName, &quot;tokenResponseHeaderName can't be null or empty!&quot;);
    }

    private boolean requireDoFilter(final HttpServletRequest request) {
        return !isLoginRequest(request) &amp;&amp; jwtAuthenticationService.isAuthRequest(request);

    }

    private boolean isLoginRequest(final HttpServletRequest request) {
        return request.getPathInfo() != null &amp;&amp; request.getPathInfo().endsWith(&quot;/auth&quot;);
    }

}
</code></pre>

<h3 id="configuració-seguretat-a-spring">Configuració Seguretat a Spring</h3>

<p>Per a utilitzar les classes que hem creat als punts anteriors, hem de realitzar la configuració de Spring Security al fitxer <strong>app-custom-security.xml</strong></p>

<p>En aquest fitxer hem de fer que Spring tingui en compte el controlador creat:</p>

<pre><code>&lt;context:component-scan base-package=&quot;cat.gencat.canigorest311.security&quot; /&gt;
</code></pre>

<p>Declarar els beans de les noves classes creades:</p>

<pre><code>&lt;bean name=&quot;jwtAuthenticationService&quot; id=&quot;jwtAuthenticationService&quot; class=&quot;cat.gencat.canigorest311.security.authentication.service.impl.JwtAuthenticationService&quot;&gt;
    &lt;property name=&quot;tokenResponseHeaderName&quot; value=&quot;${jwt.tokenResponseHeaderName:jwtToken}&quot; /&gt;
    &lt;property name=&quot;headerAuthName&quot; value=&quot;${jwt.header:Authentication}&quot; /&gt;
&lt;/bean&gt;

&lt;bean name=&quot;jwtAuthenticationFilter&quot; id=&quot;jwtAuthenticationFilter&quot; class=&quot;cat.gencat.canigorest311.security.authentication.jwt.JwtAuthenticationFilter&quot;&gt;
    &lt;property name=&quot;startToken&quot; value=&quot;${jwt.header.startToken:Bearer}&quot; /&gt;
    &lt;property name=&quot;tokenResponseHeaderName&quot; value=&quot;${jwt.tokenResponseHeaderName:jwtToken}&quot; /&gt;
    &lt;property name=&quot;headerAuthName&quot; value=&quot;${jwt.header:Authentication}&quot; /&gt;
&lt;/bean&gt;

&lt;bean name=&quot;jwtTokenHandler&quot; id=&quot;jwtTokenHandler&quot; class=&quot;cat.gencat.canigorest311.security.authentication.jwt.JwtTokenHandler&quot;&gt;
    &lt;property name=&quot;expiration&quot; value=&quot;${jwt.expiration:3600L}&quot; /&gt;
    &lt;property name=&quot;secret&quot; value=&quot;${jwt.secret:canigo}&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>Declarar el punt d&rsquo;entrada de la seguretat:</p>

<pre><code>&lt;security:http use-expressions=&quot;true&quot; create-session=&quot;stateless&quot; entry-point-ref=&quot;restAuthenticationEntryPoint&quot;&gt;
</code></pre>

<p>Declarar el filtre JWT:</p>

<pre><code>&lt;security:custom-filter ref=&quot;jwtAuthenticationFilter&quot; before=&quot;PRE_AUTH_FILTER&quot; /&gt;
</code></pre>

<p>Amb aquests canvis el fitxer quedaria de la següent manera:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans  xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:security=&quot;http://www.springframework.org/schema/security&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans-4.1.xsd
                            http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context-4.1.xsd
                            http://www.springframework.org/schema/security  http://www.springframework.org/schema/security/spring-security-3.2.xsd
                            http://www.springframework.org/schema/jdbc      http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xs&quot;&gt;

    &lt;context:component-scan base-package=&quot;cat.gencat.canigorest311.security&quot; /&gt;

    &lt;bean name=&quot;jwtAuthenticationService&quot; id=&quot;jwtAuthenticationService&quot; class=&quot;cat.gencat.canigorest311.security.authentication.service.impl.JwtAuthenticationService&quot;&gt;
        &lt;property name=&quot;tokenResponseHeaderName&quot; value=&quot;${jwt.tokenResponseHeaderName:jwtToken}&quot; /&gt;
        &lt;property name=&quot;headerAuthName&quot; value=&quot;${jwt.header:Authentication}&quot; /&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;jwtAuthenticationFilter&quot; id=&quot;jwtAuthenticationFilter&quot; class=&quot;cat.gencat.canigorest311.security.authentication.jwt.JwtAuthenticationFilter&quot;&gt;
        &lt;property name=&quot;startToken&quot; value=&quot;${jwt.header.startToken:Bearer}&quot; /&gt;
        &lt;property name=&quot;tokenResponseHeaderName&quot; value=&quot;${jwt.tokenResponseHeaderName:jwtToken}&quot; /&gt;
        &lt;property name=&quot;headerAuthName&quot; value=&quot;${jwt.header:Authentication}&quot; /&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;jwtTokenHandler&quot; id=&quot;jwtTokenHandler&quot; class=&quot;cat.gencat.canigorest311.security.authentication.jwt.JwtTokenHandler&quot;&gt;
        &lt;property name=&quot;expiration&quot; value=&quot;${jwt.expiration:3600L}&quot; /&gt;
        &lt;property name=&quot;secret&quot; value=&quot;${jwt.secret:canigo}&quot; /&gt;
    &lt;/bean&gt;

    &lt;security:http pattern=&quot;/css/**&quot; security=&quot;none&quot; /&gt;
    &lt;security:http pattern=&quot;/images/**&quot; security=&quot;none&quot; /&gt;
    &lt;security:http pattern=&quot;/js/**&quot; security=&quot;none&quot; /&gt;

    &lt;!-- Secure patterns --&gt;
    &lt;security:http use-expressions=&quot;true&quot; create-session=&quot;stateless&quot; entry-point-ref=&quot;restAuthenticationEntryPoint&quot;&gt;
        &lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;permitAll&quot; method=&quot;OPTIONS&quot; /&gt;
        &lt;security:intercept-url pattern=&quot;/api/equipaments/**&quot; access=&quot;hasRole('ROLE_ADMIN')&quot; method=&quot;DELETE&quot; /&gt;
        &lt;security:intercept-url pattern=&quot;/api/equipaments/**&quot; access=&quot;hasRole('ROLE_ADMIN')&quot; method=&quot;GET&quot; /&gt;
        &lt;security:intercept-url pattern=&quot;/api/equipaments/**&quot; access=&quot;hasRole('ROLE_ADMIN')&quot; method=&quot;PUT&quot; /&gt;
        &lt;security:intercept-url pattern=&quot;/api/equipaments/**&quot; access=&quot;hasRole('ROLE_ADMIN')&quot; method=&quot;POST&quot; /&gt;
        &lt;security:intercept-url pattern=&quot;/api/logs/**&quot; access=&quot;hasRole('ROLE_ADMIN')&quot; /&gt;

        &lt;security:form-login login-processing-url=&quot;/j_spring_security_check&quot; login-page=&quot;/j_spring_security_check&quot; /&gt;
        &lt;security:custom-filter ref=&quot;jwtAuthenticationFilter&quot; before=&quot;PRE_AUTH_FILTER&quot; /&gt;
    &lt;/security:http&gt;

    &lt;security:authentication-manager alias=&quot;authenticationManager&quot;&gt; 
        &lt;!-- BBDD --&gt;
        &lt;security:authentication-provider&gt;
            &lt;security:jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt;
        &lt;/security:authentication-provider&gt;

    &lt;/security:authentication-manager&gt;

&lt;/beans&gt;
</code></pre>

<h3 id="resultat">Resultat</h3>

<p>Amb aquesta configuració, la primera vegada que un usuari vol accedir a l&rsquo;aplicació haurà de proporcionar l&rsquo;usuari i password, i l&rsquo;aplicació a la response retornarà un token:</p>

<pre><code>jwtToken:eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE0ODA2ODc0OTcsInN1YiI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOiJST0xFX0FETUlOLFJPTEVfVVNFUiJ9.kmupP8B269D-SZemxkTdfdqYQ-vRMF3-nNtsWoi-bbDo5Wk38LbRYYf-sO3ceqZaYursfFIYyI0BR6keuko-4A
</code></pre>

<p>A partir d&rsquo;aquí, l&rsquo;aplicació ha d&rsquo;enviar aquest token a la capçalera de les següents peticions:</p>

<pre><code>Nom: Authentication
Valor: Bearer + token
</code></pre>

<p>Exemple</p>

<pre><code>Authentication: Bearer eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE0ODA2ODc0OTcsInN1YiI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOiJST0xFX0FETUlOLFJPTEVfVVNFUiJ9.kmupP8B269D-SZemxkTdfdqYQ-vRMF3-nNtsWoi-bbDo5Wk38LbRYYf-sO3ceqZaYursfFIYyI0BR6keuko-4A
</code></pre>


					

					
				</div>	

			</article>	


	</section>	

		<div class="fons_footer ">
		<footer class="container center-block shadowBox2">
			<div class="shadow2"></div>
			<div class="row footer_tab_ord">

				<div class="footer_tab_bot col-sm-12">
					<div class="avis_legal">

						<div id="fAvisLegal">
							<div>
								<div class="hidden-xs">
									<a href="https://www.gencat.cat"> <img
										src="/img/logo_generalitat_gris.png_679097835.png"
										width="101" height="27" alt="www.gencat.cat"
										/></a>
									<p>
										<a title="Avis legal" href="https://web.gencat.cat/ca/menu-ajuda/ajuda/avis_legal/" target="_self">Avís legal</a>: La &copy; Generalitat de Catalunya permet la reutilització dels continguts i de les dades sempre que se citi la font i la data d'actualització, que no es desnaturalitzi la informació i que no es contradigui amb una llicència específica.
									</p>
								</div>
								<div class="visible-xs avis_legal">
									<p>
										<a title="Avis legal" href="https://web.gencat.cat/ca/menu-ajuda/ajuda/avis_legal/" target="_self">Avís legal</a>: La &copy; Generalitat de Catalunya permet la reutilització dels continguts i de les dades sempre que se citi la font i la data d'actualització, que no es desnaturalitzi la informació i que no es contradigui amb una llicència específica.
									</p>
								</div>
								
								<div class="fi_peu visible-xs">
									<a title="www.gencat.cat" href="https://www.gencat.cat"> <img
										src="/img/logo_generalitat_gris.png_679097835.png"
										width="101" height="27" 
										alt="www.gencat.cat" /></a> <a class="torna_amunt pull-right"
										href=" javascript:tornarAmunt();" title="Torna amunt">
										<p>Torna amunt</p>
									</a>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</footer>
	</div>

<script src="/js/master.min.js" type="text/javascript"></script>
<script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
<script src="https://cdn.jsdelivr.net/autocomplete.js/0/autocomplete.min.js"></script>
<script src="/js/custom.js" type="text/javascript"></script>



<script type="text/javascript">

if(location.hostname!=="localhost"){

	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', "UA-59408075-1", 'auto');
	ga('send', 'pageview', {
	  	'page': location.pathname + location.search  + location.hash
	  }
	);

}

</script>




</body>
</html>
